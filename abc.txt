diff --git a/quickstart.py b/quickstart.py
index 37ada9e..3bbbfcb 100644
--- a/quickstart.py
+++ b/quickstart.py
@@ -1,13 +1,17 @@
 # -*- coding: utf-8 -*-
 import os
+
 import flask
 import google.oauth2.credentials
 import google_auth_oauthlib.flow
 import googleapiclient.discovery
-from flask import render_template
-from flask import Blueprint, request, url_for, redirect, session
-from flask_login import LoginManager, login_required, login_user, \
-    logout_user, current_user
+from flask_login import (
+    LoginManager,
+    current_user,
+    login_required,
+    login_user,
+    logout_user,
+)
 
 # The CLIENT_SECRETS_FILE variable specifies the name of a file that contains
 # the OAuth 2.0 information for this application, including its client_id and
@@ -16,147 +20,147 @@ CLIENT_SECRETS_FILE = "client_secret.json"
 
 # This OAuth 2.0 access scope allows for full read/write access to the
 # authenticated user's account and requires requests to use an SSL connection.
-SCOPES = ['https://www.googleapis.com/auth/youtube.force-ssl']
-API_SERVICE_NAME = 'youtube'
-API_VERSION = 'v3'
+SCOPES = ["https://www.googleapis.com/auth/youtube.force-ssl"]
+API_SERVICE_NAME = "youtube"
+API_VERSION = "v3"
 
 app = flask.Flask(__name__)
+
 # Note: A secret key is included in the sample so that it works, but if you
 # use this code in your application please replace this with a truly secret
 # key. See http://flask.pocoo.org/docs/0.12/quickstart/#sessions.
-app.secret_key = 'secret key'
+app.secret_key = "<something really secret which should be taken from environment variable"
+
 login_manager = LoginManager(app)
 login_manager.login_view = "login"
 
 
-@app.route('/')
-def login():  
-	return flask.redirect(flask.url_for('authorize'))
+@app.route("/")
+def login():
+    return flask.redirect(flask.url_for("authorize"))
 
 
-@app.route('/home')
+@app.route("/home")
 def home():
+    return flask.redirect(flask.url_for("search"))
 
-	return flask.redirect(flask.url_for('search'))
 
-
-@app.route('/search',methods=['POST','GET'])
+@app.route("/search", methods=["POST", "GET"])
 def search():
- 
-	if request.method == "POST":
-		session['querry'] = request.form['querry']
-		return flask.redirect(flask.url_for('result'))
+    if flask.request.method == "POST":
+        flask.session["querry"] = flask.request.form["querry"]
+        return flask.redirect(flask.url_for("result"))
+
+    return flask.render_template("index.html")
 
-	return render_template("index.html")
 
-@app.route('/result')
+@app.route("/result")
 def result():
-	if 'credentials' not in flask.session:
-		return flask.redirect('login')
-
-  	# Load the credentials from the session.
-	credentials = google.oauth2.credentials.Credentials(
-		  **flask.session['credentials'])
-
-	client = googleapiclient.discovery.build(
-		API_SERVICE_NAME, API_VERSION, credentials=credentials) 
-	querry = session['querry']
-	print ( querry )
-	response = search_list_by_keyword(client,
-							part='snippet',
-    					maxResults=25,
-    					q=querry,
-    					type='')
-	length = len(response['items'])
-	session.clear()
-	return render_template("results.html", response = response, length = length)
-
-@app.route('/authorize')
+    if "credentials" not in flask.session:
+        return flask.redirect("login")
+
+    # Load the credentials from the session.
+    credentials = google.oauth2.credentials.Credentials(**flask.session["credentials"])
+
+    client = googleapiclient.discovery.build(
+        API_SERVICE_NAME, API_VERSION, credentials=credentials
+    )
+    querry = flask.session["querry"]
+    response = search_list_by_keyword(
+        client, part="snippet", maxResults=25, q=querry, type=""
+    )
+    length = len(response["items"])
+    flask.session.clear()
+    return flask.render_template("results.html", response=response, length=length)
+
+
+@app.route("/authorize")
 def authorize():
-  # Create a flow instance to manage the OAuth 2.0 Authorization Grant Flow
-  # steps.
-	flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-	CLIENT_SECRETS_FILE, scopes=SCOPES)
-
-	flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
-	authorization_url, state = flow.authorization_url(
-      # This parameter enables offline access which gives your application
-      # both an access and refresh token.
-		access_type='offline',
-      # This parameter enables incremental auth.
-		include_granted_scopes='true')
-
-  # Store the state in the session so that the callback can verify that
-  # the authorization server response.
-	flask.session['state'] = state
-	return flask.redirect(authorization_url)
-
-
-@app.route('/oauth2callback')
+    # Create a flow instance to manage the OAuth 2.0 Authorization Grant Flow
+    # steps.
+    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
+        CLIENT_SECRETS_FILE, scopes=SCOPES
+    )
+
+    flow.redirect_uri = flask.url_for("oauth2callback", _external=True)
+    authorization_url, state = flow.authorization_url(
+        # This parameter enables offline access which gives your application
+        # both an access and refresh token.
+        access_type="offline",
+        # This parameter enables incremental auth.
+        include_granted_scopes="true",
+    )
+
+    # Store the state in the session so that the callback can verify that
+    # the authorization server response.
+    flask.session["state"] = state
+    return flask.redirect(authorization_url)
+
+
+@app.route("/oauth2callback")
 def oauth2callback():
-  # Specify the state when creating the flow in the callback so that it can
-  # verify the authorization server response.
-	state = flask.session['state']
-	flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-    CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)
-	flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
-
-  # Use the authorization server's response to fetch the OAuth 2.0 tokens.
-	authorization_response = flask.request.url
-	flow.fetch_token(authorization_response=authorization_response)
-
-  # Store the credentials in the session.
-  # ACTION ITEM for developers:
-  #     Store user's access and refresh tokens in your data store if
-  #     incorporating this code into your real app.
-	credentials = flow.credentials
-	flask.session['credentials'] = {
-    'token': credentials.token,
-  	'refresh_token': credentials.refresh_token,
-  	'token_uri': credentials.token_uri,
-  	'client_id': credentials.client_id,
-  	'client_secret': credentials.client_secret,
-  	'scopes': credentials.scopes
-  	}
-	flask.session['logged_in'] = True 
-	return flask.redirect(flask.url_for('home'))
-
-@app.route('/logout')
+    # Specify the state when creating the flow in the callback so that it can
+    # verify the authorization server response.
+    state = flask.session["state"]
+    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
+        CLIENT_SECRETS_FILE, scopes=SCOPES, state=state
+    )
+    flow.redirect_uri = flask.url_for("oauth2callback", _external=True)
+
+    # Use the authorization server's response to fetch the OAuth 2.0 tokens.
+    authorization_response = flask.request.url
+    flow.fetch_token(authorization_response=authorization_response)
+
+    # Store the credentials in the session.
+    # ACTION ITEM for developers:
+    #     Store user's access and refresh tokens in your data store if
+    #     incorporating this code into your real app.
+    credentials = flow.credentials
+    flask.session["credentials"] = {
+        "token": credentials.token,
+        "refresh_token": credentials.refresh_token,
+        "token_uri": credentials.token_uri,
+        "client_id": credentials.client_id,
+        "client_secret": credentials.client_secret,
+        "scopes": credentials.scopes,
+    }
+    flask.session["logged_in"] = True
+    return flask.redirect(flask.url_for("home"))
+
+
+@app.route("/logout")
 def logout():
-  logout_user()
-  #flask.session.pop('credentials', None)
-  flask.session.clear()
-  return redirect(url_for('login'))
+    logout_user()
+    # flask.session.pop('credentials', None)
+    flask.session.clear()
+    return redirect(url_for("login"))
 
 
 def channels_list_by_username(client, **kwargs):
-  	response = client.channels().list(
-    **kwargs
-  	).execute()
-  	return flask.jsonify(**response)
+    response = client.channels().list(**kwargs).execute()
+    return flask.jsonify(**response)
 
 
 def search_list_by_keyword(client, **kwargs):
-  # See full sample for function
-  # print (flask.session['credentials']['client_id'])
-		response = client.search().list(
-		**kwargs
-		).execute()
-		return response
+    # See full sample for function
+    response = client.search().list(**kwargs).execute()
+    return response
+
 
 def login_required(f):
     @wraps(f)
     def wrap(*args, **kwargs):
-        if 'logged_in' in session:
-            return f(*args,**kwargs)
+        if "logged_in" in flask.session:
+            return f(*args, **kwargs)
         else:
             flash("Login Required")
-            return redirect(url_for('login'))
-            
+            return redirect(url_for("login"))
+
     return wrap
 
-if __name__ == '__main__':
-  # When running locally, disable OAuthlib's HTTPs verification. When
-  # running in production *do not* leave this option enabled.
-	os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'
-	app.run(host='0.0.0.0', port=5000, debug=True)
+
+if __name__ == "__main__":
+    # When running locally, disable OAuthlib's HTTPs verification. When
+    # running in production *do not* leave this option enabled.
+    os.environ["OAUTHLIB_INSECURE_TRANSPORT"] = "1"
+    app.run(host="localhost", port=5000, debug=True)
diff --git a/requirements.txt b/requirements.txt
index 5a1ae59..6ce99b2 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -9,4 +9,3 @@ Werkzeug==0.14.1
 pytz==2018.4
 simplejson==3.16.0
 Flask-Login
-Flask-SQLAlchemy
diff --git a/templates/header.html b/templates/header.html
index 56f1700..350c050 100644
--- a/templates/header.html
+++ b/templates/header.html
@@ -1,4 +1,5 @@
-<!Doctype html>
+<!doctype html>
+
 <html>
   <head>
     <meta charset="utf-8">
@@ -23,8 +24,8 @@
             </ul>
           </div>
         </nav>
-      </header>      
-      {% block content %}{% endblock %}
-      
+      </header>
+    {% block content %}{% endblock %}
+
   </body>
-</html>
\ No newline at end of file
+</html>
diff --git a/templates/index.html b/templates/index.html
index 2912491..4846db9 100644
--- a/templates/index.html
+++ b/templates/index.html
@@ -2,10 +2,10 @@
 {% block content%}
   
 <form method="POST">
-    <div class="container">
-      <input id="querry" name="querry" type="text" placeholder="Search.." value="{{ request.form.querry }}">
-      <button> search </button>
-    </div>
+  <div class="container">
+    <input id="querry" name="querry" type="text" placeholder="Search.." value="{{ request.form.querry }}">
+    <button> search </button>
+  </div>
 </form>
   
-{%endblock%}
\ No newline at end of file
+{%endblock%}
diff --git a/templates/results.html b/templates/results.html
index cda3738..03fd6be 100644
--- a/templates/results.html
+++ b/templates/results.html
@@ -1,21 +1,20 @@
 {% extends "header.html" %}
 {% block content%}
 
-
 <div class="container">
-	<div class="sort">
-			<select>
-					<option value="volvo">Name</option>
-					<option value="saab">Date</option>
-				  </select> 
-	</div>
+  <div class="sort">
+    <select>
+      <option value="volvo">Name</option>
+      <option value="saab">Date</option>
+    </select> 
+  </div>
 </div>
 <div class="container" >
-	<div id="result" class="result">
-	{% for i in range(0,length) %}
-	<iframe width="560" height="400" src="https://www.youtube.com/embed/{{ response['items'][i]['id']['videoId'] }}" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
-	{% endfor %}
-	</div>
+  <div id="result" class="result">
+    {% for i in range(0,length) %}
+    <iframe width="560" height="400" src="https://www.youtube.com/embed/{{ response['items'][i]['id']['videoId'] }}" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
+    {% endfor %}
+  </div>
 </div>
 
-{%endblock%}
\ No newline at end of file
+{%endblock%}
diff --git a/views/__pycache__/login.cpython-36.pyc b/views/__pycache__/login.cpython-36.pyc
deleted file mode 100644
index 2b425e2..0000000
Binary files a/views/__pycache__/login.cpython-36.pyc and /dev/null differ
diff --git a/views/login.py b/views/login.py
deleted file mode 100644
index fef8a8c..0000000
--- a/views/login.py
+++ /dev/null
@@ -1,67 +0,0 @@
-from flask import Blueprint, redirect, url_for, session, request, jsonify, render_template
-from flask_login import login_required, login_user, \
-    logout_user, current_user
-from config import Auth
-import json
-from app import oauth, login_manager, db
-
-
-google = oauth.remote_app(
-    'google',
-    consumer_key=Auth.CLIENT_ID,
-    consumer_secret=Auth.CLIENT_SECRET,
-    request_token_params={
-        'scope': 'https://www.googleapis.com/auth/userinfo.email'
-    },
-    base_url=Auth.BASE_URL,
-    request_token_url=None,
-    access_token_method='POST',
-    access_token_url=Auth.ACCESS_TOKEN_URL,
-    authorize_url=Auth.AUTHORIZE_URL,
-)
-
-login_routes = Blueprint('login', __name__)
-
-
-@login_routes.route('/')
-def index():
-    # if current_user.is_authenticated:
-    #     return jsonify(current_user.email)
-    return render_template('index.html')
-
-
-@login_routes.route('/login')
-def login():
-    return google.authorize(callback=url_for('login.authorized', _external=True))
-
-
-@login_routes.route('/logout')
-@login_required
-def logout():
-    logout_user()
-    session.pop('google_token', None)
-    return redirect(url_for('login.index'))
-
-
-@login_routes.route('/oauth2callback')
-@google.authorized_handler
-def authorized(resp):
-    if resp is None:
-        return 'Access denied: reason=%s error=%s' % (
-            request.args['error_reason'],
-            request.args['error_description']
-        )
-    session['google_token'] = (resp['access_token'], '')
-    me = google.get('userinfo')
-    user_data = me.data
-    print(user_data)
-    return redirect(url_for('login.index'))
-
-
-@google.tokengetter
-def get_google_oauth_token():
-    return session.get('google_token')
-
-@login_manager.user_loader
-def load_user(user_id):
-    return User.query.get(int(user_id))
\ No newline at end of file
diff --git a/views/youtube.py b/views/youtube.py
deleted file mode 100644
index fa1e6a3..0000000
--- a/views/youtube.py
+++ /dev/null
@@ -1,111 +0,0 @@
-# -*- coding: utf-8 -*-
-from flask import Blueprint, redirect, url_for, session, request, jsonify, render_template
-from flask_login import login_required, login_user, \
-    logout_user, current_user
-import os
-
-
-# This OAuth 2.0 access scope allows for full read/write access to the
-# authenticated user's account and requires requests to use an SSL connection.
-SCOPES = ['https://www.googleapis.com/auth/youtube.force-ssl']
-API_SERVICE_NAME = 'youtube'
-API_VERSION = 'v3'
-
-
-youtube_routes = Blueprint('youtube', __name__)
-
-@app.route('/home)
-def home():
-  return
-
-
-
-
-@app.route('/')
-def index():
-  if 'credentials' not in flask.session:
-    return flask.redirect('authorize')
-
-  # Load the credentials from the session.
-  credentials = google.oauth2.credentials.Credentials(
-      **flask.session['credentials'])
-
-  client = googleapiclient.discovery.build(
-      API_SERVICE_NAME, API_VERSION, credentials=credentials)
-  
-  return search_list_by_keyword(client,
-    part='snippet',
-    maxResults=25,
-    q='dogs',
-    type='')
-
-
-@app.route('/authorize')
-def authorize():
-  # Create a flow instance to manage the OAuth 2.0 Authorization Grant Flow
-  # steps.
-  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-      CLIENT_SECRETS_FILE, scopes=SCOPES)
-  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
-  authorization_url, state = flow.authorization_url(
-      # This parameter enables offline access which gives your application
-      # both an access and refresh token.
-      access_type='offline',
-      # This parameter enables incremental auth.
-      include_granted_scopes='true')
-
-  # Store the state in the session so that the callback can verify that
-  # the authorization server response.
-  flask.session['state'] = state
-
-  return flask.redirect(authorization_url)
-
-
-@app.route('/oauth2callback')
-def oauth2callback():
-  # Specify the state when creating the flow in the callback so that it can
-  # verify the authorization server response.
-  state = flask.session['state']
-  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-      CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)
-  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
-
-  # Use the authorization server's response to fetch the OAuth 2.0 tokens.
-  authorization_response = flask.request.url
-  flow.fetch_token(authorization_response=authorization_response)
-
-  # Store the credentials in the session.
-  # ACTION ITEM for developers:
-  #     Store user's access and refresh tokens in your data store if
-  #     incorporating this code into your real app.
-  credentials = flow.credentials
-  flask.session['credentials'] = {
-      'token': credentials.token,
-      'refresh_token': credentials.refresh_token,
-      'token_uri': credentials.token_uri,
-      'client_id': credentials.client_id,
-      'client_secret': credentials.client_secret,
-      'scopes': credentials.scopes
-  }
-
-  return flask.redirect(flask.url_for('index'))
-
-def channels_list_by_username(client, **kwargs):
-  response = client.channels().list(
-    **kwargs
-  ).execute()
-
-  return flask.jsonify(**response)
-
-def print_response(response):
-  print(response)
-
-def search_list_by_keyword(client, **kwargs):
-  # See full sample for function
-  print (flask.session['credentials']['client_id'])
-  response = client.search().list(
-    **kwargs
-  ).execute()
-  print ( response['items'])
-  return flask.jsonify(**response)
-
diff --git a/abc.txt b/abc.txt
index 0166f39..e69de29 100644
--- a/abc.txt
+++ b/abc.txt
@@ -1,572 +0,0 @@
-diff --git a/quickstart.py b/quickstart.py
-index 37ada9e..3bbbfcb 100644
---- a/quickstart.py
-+++ b/quickstart.py
-@@ -1,13 +1,17 @@
- # -*- coding: utf-8 -*-
- import os
-+
- import flask
- import google.oauth2.credentials
- import google_auth_oauthlib.flow
- import googleapiclient.discovery
--from flask import render_template
--from flask import Blueprint, request, url_for, redirect, session
--from flask_login import LoginManager, login_required, login_user, \
--    logout_user, current_user
-+from flask_login import (
-+    LoginManager,
-+    current_user,
-+    login_required,
-+    login_user,
-+    logout_user,
-+)
- 
- # The CLIENT_SECRETS_FILE variable specifies the name of a file that contains
- # the OAuth 2.0 information for this application, including its client_id and
-@@ -16,147 +20,147 @@ CLIENT_SECRETS_FILE = "client_secret.json"
- 
- # This OAuth 2.0 access scope allows for full read/write access to the
- # authenticated user's account and requires requests to use an SSL connection.
--SCOPES = ['https://www.googleapis.com/auth/youtube.force-ssl']
--API_SERVICE_NAME = 'youtube'
--API_VERSION = 'v3'
-+SCOPES = ["https://www.googleapis.com/auth/youtube.force-ssl"]
-+API_SERVICE_NAME = "youtube"
-+API_VERSION = "v3"
- 
- app = flask.Flask(__name__)
-+
- # Note: A secret key is included in the sample so that it works, but if you
- # use this code in your application please replace this with a truly secret
- # key. See http://flask.pocoo.org/docs/0.12/quickstart/#sessions.
--app.secret_key = 'secret key'
-+app.secret_key = "<something really secret which should be taken from environment variable"
-+
- login_manager = LoginManager(app)
- login_manager.login_view = "login"
- 
- 
--@app.route('/')
--def login():  
--	return flask.redirect(flask.url_for('authorize'))
-+@app.route("/")
-+def login():
-+    return flask.redirect(flask.url_for("authorize"))
- 
- 
--@app.route('/home')
-+@app.route("/home")
- def home():
-+    return flask.redirect(flask.url_for("search"))
- 
--	return flask.redirect(flask.url_for('search'))
- 
--
--@app.route('/search',methods=['POST','GET'])
-+@app.route("/search", methods=["POST", "GET"])
- def search():
-- 
--	if request.method == "POST":
--		session['querry'] = request.form['querry']
--		return flask.redirect(flask.url_for('result'))
-+    if flask.request.method == "POST":
-+        flask.session["querry"] = flask.request.form["querry"]
-+        return flask.redirect(flask.url_for("result"))
-+
-+    return flask.render_template("index.html")
- 
--	return render_template("index.html")
- 
--@app.route('/result')
-+@app.route("/result")
- def result():
--	if 'credentials' not in flask.session:
--		return flask.redirect('login')
--
--  	# Load the credentials from the session.
--	credentials = google.oauth2.credentials.Credentials(
--		  **flask.session['credentials'])
--
--	client = googleapiclient.discovery.build(
--		API_SERVICE_NAME, API_VERSION, credentials=credentials) 
--	querry = session['querry']
--	print ( querry )
--	response = search_list_by_keyword(client,
--							part='snippet',
--    					maxResults=25,
--    					q=querry,
--    					type='')
--	length = len(response['items'])
--	session.clear()
--	return render_template("results.html", response = response, length = length)
--
--@app.route('/authorize')
-+    if "credentials" not in flask.session:
-+        return flask.redirect("login")
-+
-+    # Load the credentials from the session.
-+    credentials = google.oauth2.credentials.Credentials(**flask.session["credentials"])
-+
-+    client = googleapiclient.discovery.build(
-+        API_SERVICE_NAME, API_VERSION, credentials=credentials
-+    )
-+    querry = flask.session["querry"]
-+    response = search_list_by_keyword(
-+        client, part="snippet", maxResults=25, q=querry, type=""
-+    )
-+    length = len(response["items"])
-+    flask.session.clear()
-+    return flask.render_template("results.html", response=response, length=length)
-+
-+
-+@app.route("/authorize")
- def authorize():
--  # Create a flow instance to manage the OAuth 2.0 Authorization Grant Flow
--  # steps.
--	flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
--	CLIENT_SECRETS_FILE, scopes=SCOPES)
--
--	flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
--	authorization_url, state = flow.authorization_url(
--      # This parameter enables offline access which gives your application
--      # both an access and refresh token.
--		access_type='offline',
--      # This parameter enables incremental auth.
--		include_granted_scopes='true')
--
--  # Store the state in the session so that the callback can verify that
--  # the authorization server response.
--	flask.session['state'] = state
--	return flask.redirect(authorization_url)
--
--
--@app.route('/oauth2callback')
-+    # Create a flow instance to manage the OAuth 2.0 Authorization Grant Flow
-+    # steps.
-+    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-+        CLIENT_SECRETS_FILE, scopes=SCOPES
-+    )
-+
-+    flow.redirect_uri = flask.url_for("oauth2callback", _external=True)
-+    authorization_url, state = flow.authorization_url(
-+        # This parameter enables offline access which gives your application
-+        # both an access and refresh token.
-+        access_type="offline",
-+        # This parameter enables incremental auth.
-+        include_granted_scopes="true",
-+    )
-+
-+    # Store the state in the session so that the callback can verify that
-+    # the authorization server response.
-+    flask.session["state"] = state
-+    return flask.redirect(authorization_url)
-+
-+
-+@app.route("/oauth2callback")
- def oauth2callback():
--  # Specify the state when creating the flow in the callback so that it can
--  # verify the authorization server response.
--	state = flask.session['state']
--	flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
--    CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)
--	flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
--
--  # Use the authorization server's response to fetch the OAuth 2.0 tokens.
--	authorization_response = flask.request.url
--	flow.fetch_token(authorization_response=authorization_response)
--
--  # Store the credentials in the session.
--  # ACTION ITEM for developers:
--  #     Store user's access and refresh tokens in your data store if
--  #     incorporating this code into your real app.
--	credentials = flow.credentials
--	flask.session['credentials'] = {
--    'token': credentials.token,
--  	'refresh_token': credentials.refresh_token,
--  	'token_uri': credentials.token_uri,
--  	'client_id': credentials.client_id,
--  	'client_secret': credentials.client_secret,
--  	'scopes': credentials.scopes
--  	}
--	flask.session['logged_in'] = True 
--	return flask.redirect(flask.url_for('home'))
--
--@app.route('/logout')
-+    # Specify the state when creating the flow in the callback so that it can
-+    # verify the authorization server response.
-+    state = flask.session["state"]
-+    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-+        CLIENT_SECRETS_FILE, scopes=SCOPES, state=state
-+    )
-+    flow.redirect_uri = flask.url_for("oauth2callback", _external=True)
-+
-+    # Use the authorization server's response to fetch the OAuth 2.0 tokens.
-+    authorization_response = flask.request.url
-+    flow.fetch_token(authorization_response=authorization_response)
-+
-+    # Store the credentials in the session.
-+    # ACTION ITEM for developers:
-+    #     Store user's access and refresh tokens in your data store if
-+    #     incorporating this code into your real app.
-+    credentials = flow.credentials
-+    flask.session["credentials"] = {
-+        "token": credentials.token,
-+        "refresh_token": credentials.refresh_token,
-+        "token_uri": credentials.token_uri,
-+        "client_id": credentials.client_id,
-+        "client_secret": credentials.client_secret,
-+        "scopes": credentials.scopes,
-+    }
-+    flask.session["logged_in"] = True
-+    return flask.redirect(flask.url_for("home"))
-+
-+
-+@app.route("/logout")
- def logout():
--  logout_user()
--  #flask.session.pop('credentials', None)
--  flask.session.clear()
--  return redirect(url_for('login'))
-+    logout_user()
-+    # flask.session.pop('credentials', None)
-+    flask.session.clear()
-+    return redirect(url_for("login"))
- 
- 
- def channels_list_by_username(client, **kwargs):
--  	response = client.channels().list(
--    **kwargs
--  	).execute()
--  	return flask.jsonify(**response)
-+    response = client.channels().list(**kwargs).execute()
-+    return flask.jsonify(**response)
- 
- 
- def search_list_by_keyword(client, **kwargs):
--  # See full sample for function
--  # print (flask.session['credentials']['client_id'])
--		response = client.search().list(
--		**kwargs
--		).execute()
--		return response
-+    # See full sample for function
-+    response = client.search().list(**kwargs).execute()
-+    return response
-+
- 
- def login_required(f):
-     @wraps(f)
-     def wrap(*args, **kwargs):
--        if 'logged_in' in session:
--            return f(*args,**kwargs)
-+        if "logged_in" in flask.session:
-+            return f(*args, **kwargs)
-         else:
-             flash("Login Required")
--            return redirect(url_for('login'))
--            
-+            return redirect(url_for("login"))
-+
-     return wrap
- 
--if __name__ == '__main__':
--  # When running locally, disable OAuthlib's HTTPs verification. When
--  # running in production *do not* leave this option enabled.
--	os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'
--	app.run(host='0.0.0.0', port=5000, debug=True)
-+
-+if __name__ == "__main__":
-+    # When running locally, disable OAuthlib's HTTPs verification. When
-+    # running in production *do not* leave this option enabled.
-+    os.environ["OAUTHLIB_INSECURE_TRANSPORT"] = "1"
-+    app.run(host="localhost", port=5000, debug=True)
-diff --git a/requirements.txt b/requirements.txt
-index 5a1ae59..6ce99b2 100644
---- a/requirements.txt
-+++ b/requirements.txt
-@@ -9,4 +9,3 @@ Werkzeug==0.14.1
- pytz==2018.4
- simplejson==3.16.0
- Flask-Login
--Flask-SQLAlchemy
-diff --git a/templates/header.html b/templates/header.html
-index 56f1700..350c050 100644
---- a/templates/header.html
-+++ b/templates/header.html
-@@ -1,4 +1,5 @@
--<!Doctype html>
-+<!doctype html>
-+
- <html>
-   <head>
-     <meta charset="utf-8">
-@@ -23,8 +24,8 @@
-             </ul>
-           </div>
-         </nav>
--      </header>      
--      {% block content %}{% endblock %}
--      
-+      </header>
-+    {% block content %}{% endblock %}
-+
-   </body>
--</html>
-\ No newline at end of file
-+</html>
-diff --git a/templates/index.html b/templates/index.html
-index 2912491..4846db9 100644
---- a/templates/index.html
-+++ b/templates/index.html
-@@ -2,10 +2,10 @@
- {% block content%}
-   
- <form method="POST">
--    <div class="container">
--      <input id="querry" name="querry" type="text" placeholder="Search.." value="{{ request.form.querry }}">
--      <button> search </button>
--    </div>
-+  <div class="container">
-+    <input id="querry" name="querry" type="text" placeholder="Search.." value="{{ request.form.querry }}">
-+    <button> search </button>
-+  </div>
- </form>
-   
--{%endblock%}
-\ No newline at end of file
-+{%endblock%}
-diff --git a/templates/results.html b/templates/results.html
-index cda3738..03fd6be 100644
---- a/templates/results.html
-+++ b/templates/results.html
-@@ -1,21 +1,20 @@
- {% extends "header.html" %}
- {% block content%}
- 
--
- <div class="container">
--	<div class="sort">
--			<select>
--					<option value="volvo">Name</option>
--					<option value="saab">Date</option>
--				  </select> 
--	</div>
-+  <div class="sort">
-+    <select>
-+      <option value="volvo">Name</option>
-+      <option value="saab">Date</option>
-+    </select> 
-+  </div>
- </div>
- <div class="container" >
--	<div id="result" class="result">
--	{% for i in range(0,length) %}
--	<iframe width="560" height="400" src="https://www.youtube.com/embed/{{ response['items'][i]['id']['videoId'] }}" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
--	{% endfor %}
--	</div>
-+  <div id="result" class="result">
-+    {% for i in range(0,length) %}
-+    <iframe width="560" height="400" src="https://www.youtube.com/embed/{{ response['items'][i]['id']['videoId'] }}" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
-+    {% endfor %}
-+  </div>
- </div>
- 
--{%endblock%}
-\ No newline at end of file
-+{%endblock%}
-diff --git a/views/__pycache__/login.cpython-36.pyc b/views/__pycache__/login.cpython-36.pyc
-deleted file mode 100644
-index 2b425e2..0000000
-Binary files a/views/__pycache__/login.cpython-36.pyc and /dev/null differ
-diff --git a/views/login.py b/views/login.py
-deleted file mode 100644
-index fef8a8c..0000000
---- a/views/login.py
-+++ /dev/null
-@@ -1,67 +0,0 @@
--from flask import Blueprint, redirect, url_for, session, request, jsonify, render_template
--from flask_login import login_required, login_user, \
--    logout_user, current_user
--from config import Auth
--import json
--from app import oauth, login_manager, db
--
--
--google = oauth.remote_app(
--    'google',
--    consumer_key=Auth.CLIENT_ID,
--    consumer_secret=Auth.CLIENT_SECRET,
--    request_token_params={
--        'scope': 'https://www.googleapis.com/auth/userinfo.email'
--    },
--    base_url=Auth.BASE_URL,
--    request_token_url=None,
--    access_token_method='POST',
--    access_token_url=Auth.ACCESS_TOKEN_URL,
--    authorize_url=Auth.AUTHORIZE_URL,
--)
--
--login_routes = Blueprint('login', __name__)
--
--
--@login_routes.route('/')
--def index():
--    # if current_user.is_authenticated:
--    #     return jsonify(current_user.email)
--    return render_template('index.html')
--
--
--@login_routes.route('/login')
--def login():
--    return google.authorize(callback=url_for('login.authorized', _external=True))
--
--
--@login_routes.route('/logout')
--@login_required
--def logout():
--    logout_user()
--    session.pop('google_token', None)
--    return redirect(url_for('login.index'))
--
--
--@login_routes.route('/oauth2callback')
--@google.authorized_handler
--def authorized(resp):
--    if resp is None:
--        return 'Access denied: reason=%s error=%s' % (
--            request.args['error_reason'],
--            request.args['error_description']
--        )
--    session['google_token'] = (resp['access_token'], '')
--    me = google.get('userinfo')
--    user_data = me.data
--    print(user_data)
--    return redirect(url_for('login.index'))
--
--
--@google.tokengetter
--def get_google_oauth_token():
--    return session.get('google_token')
--
--@login_manager.user_loader
--def load_user(user_id):
--    return User.query.get(int(user_id))
-\ No newline at end of file
-diff --git a/views/youtube.py b/views/youtube.py
-deleted file mode 100644
-index fa1e6a3..0000000
---- a/views/youtube.py
-+++ /dev/null
-@@ -1,111 +0,0 @@
--# -*- coding: utf-8 -*-
--from flask import Blueprint, redirect, url_for, session, request, jsonify, render_template
--from flask_login import login_required, login_user, \
--    logout_user, current_user
--import os
--
--
--# This OAuth 2.0 access scope allows for full read/write access to the
--# authenticated user's account and requires requests to use an SSL connection.
--SCOPES = ['https://www.googleapis.com/auth/youtube.force-ssl']
--API_SERVICE_NAME = 'youtube'
--API_VERSION = 'v3'
--
--
--youtube_routes = Blueprint('youtube', __name__)
--
--@app.route('/home)
--def home():
--  return
--
--
--
--
--@app.route('/')
--def index():
--  if 'credentials' not in flask.session:
--    return flask.redirect('authorize')
--
--  # Load the credentials from the session.
--  credentials = google.oauth2.credentials.Credentials(
--      **flask.session['credentials'])
--
--  client = googleapiclient.discovery.build(
--      API_SERVICE_NAME, API_VERSION, credentials=credentials)
--  
--  return search_list_by_keyword(client,
--    part='snippet',
--    maxResults=25,
--    q='dogs',
--    type='')
--
--
--@app.route('/authorize')
--def authorize():
--  # Create a flow instance to manage the OAuth 2.0 Authorization Grant Flow
--  # steps.
--  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
--      CLIENT_SECRETS_FILE, scopes=SCOPES)
--  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
--  authorization_url, state = flow.authorization_url(
--      # This parameter enables offline access which gives your application
--      # both an access and refresh token.
--      access_type='offline',
--      # This parameter enables incremental auth.
--      include_granted_scopes='true')
--
--  # Store the state in the session so that the callback can verify that
--  # the authorization server response.
--  flask.session['state'] = state
--
--  return flask.redirect(authorization_url)
--
--
--@app.route('/oauth2callback')
--def oauth2callback():
--  # Specify the state when creating the flow in the callback so that it can
--  # verify the authorization server response.
--  state = flask.session['state']
--  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
--      CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)
--  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
--
--  # Use the authorization server's response to fetch the OAuth 2.0 tokens.
--  authorization_response = flask.request.url
--  flow.fetch_token(authorization_response=authorization_response)
--
--  # Store the credentials in the session.
--  # ACTION ITEM for developers:
--  #     Store user's access and refresh tokens in your data store if
--  #     incorporating this code into your real app.
--  credentials = flow.credentials
--  flask.session['credentials'] = {
--      'token': credentials.token,
--      'refresh_token': credentials.refresh_token,
--      'token_uri': credentials.token_uri,
--      'client_id': credentials.client_id,
--      'client_secret': credentials.client_secret,
--      'scopes': credentials.scopes
--  }
--
--  return flask.redirect(flask.url_for('index'))
--
--def channels_list_by_username(client, **kwargs):
--  response = client.channels().list(
--    **kwargs
--  ).execute()
--
--  return flask.jsonify(**response)
--
--def print_response(response):
--  print(response)
--
--def search_list_by_keyword(client, **kwargs):
--  # See full sample for function
--  print (flask.session['credentials']['client_id'])
--  response = client.search().list(
--    **kwargs
--  ).execute()
--  print ( response['items'])
--  return flask.jsonify(**response)
--
diff --git a/login.py b/login.py
deleted file mode 100644
index fef8a8c..0000000
--- a/login.py
+++ /dev/null
@@ -1,67 +0,0 @@
-from flask import Blueprint, redirect, url_for, session, request, jsonify, render_template
-from flask_login import login_required, login_user, \
-    logout_user, current_user
-from config import Auth
-import json
-from app import oauth, login_manager, db
-
-
-google = oauth.remote_app(
-    'google',
-    consumer_key=Auth.CLIENT_ID,
-    consumer_secret=Auth.CLIENT_SECRET,
-    request_token_params={
-        'scope': 'https://www.googleapis.com/auth/userinfo.email'
-    },
-    base_url=Auth.BASE_URL,
-    request_token_url=None,
-    access_token_method='POST',
-    access_token_url=Auth.ACCESS_TOKEN_URL,
-    authorize_url=Auth.AUTHORIZE_URL,
-)
-
-login_routes = Blueprint('login', __name__)
-
-
-@login_routes.route('/')
-def index():
-    # if current_user.is_authenticated:
-    #     return jsonify(current_user.email)
-    return render_template('index.html')
-
-
-@login_routes.route('/login')
-def login():
-    return google.authorize(callback=url_for('login.authorized', _external=True))
-
-
-@login_routes.route('/logout')
-@login_required
-def logout():
-    logout_user()
-    session.pop('google_token', None)
-    return redirect(url_for('login.index'))
-
-
-@login_routes.route('/oauth2callback')
-@google.authorized_handler
-def authorized(resp):
-    if resp is None:
-        return 'Access denied: reason=%s error=%s' % (
-            request.args['error_reason'],
-            request.args['error_description']
-        )
-    session['google_token'] = (resp['access_token'], '')
-    me = google.get('userinfo')
-    user_data = me.data
-    print(user_data)
-    return redirect(url_for('login.index'))
-
-
-@google.tokengetter
-def get_google_oauth_token():
-    return session.get('google_token')
-
-@login_manager.user_loader
-def load_user(user_id):
-    return User.query.get(int(user_id))
\ No newline at end of file
diff --git a/requirements.txt.rej b/requirements.txt.rej
deleted file mode 100644
index f0eef5a..0000000
--- a/requirements.txt.rej
+++ /dev/null
@@ -1,5 +0,0 @@
- Werkzeug==0.14.1
- pytz==2018.4
- simplejson==3.16.0
- Flask-Login
--Flask-SQLAlchemy
diff --git a/templates/header.html.orig b/templates/header.html.orig
deleted file mode 100644
index 6c2b7e8..0000000
--- a/templates/header.html.orig
+++ /dev/null
@@ -1,34 +0,0 @@
-<!Doctype html>
-<html>
-  <head>
-    <meta charset="utf-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1">
-    <!-- Compiled and minified CSS -->
-    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
-    <link href="{{ url_for('static', filename='css/style.css') }}" rel="stylesheet">
-
-    <link rel="stylesheet" type="text/css" href="font-awesome/css/font-awesome.min.css">
-    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.0/jquery.min.js"></script>
-    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>    
-  </head>
-  <body>
-      <header>
-        <nav>
-          <div class="nav-wrapper">
-            <a href="#" class="brand-logo">Logo</a>
-            <ul id="nav-mobile" class="right hide-on-med-and-down">
-              <li class="current"><a href="{{ url_for('home')}}">HOME</a></li>
-              {% if session.logged_in %}
-                <li><a href="{{ url_for('logout') }}">Logout</a></li>
-              {% else %}
-                <li><a href="{{url_for('login') }}">Login</a></li>
-              {% endif %}
-              
-            </ul>
-          </div>
-        </nav>
-      </header>      
-      {% block content %}{% endblock %}
-      
-  </body>
-</html>
\ No newline at end of file
diff --git a/views/__pycache__/login.cpython-36.pyc b/views/__pycache__/login.cpython-36.pyc
deleted file mode 100644
index 2b425e2..0000000
Binary files a/views/__pycache__/login.cpython-36.pyc and /dev/null differ
diff --git a/views/login.py b/views/login.py
deleted file mode 100644
index fef8a8c..0000000
--- a/views/login.py
+++ /dev/null
@@ -1,67 +0,0 @@
-from flask import Blueprint, redirect, url_for, session, request, jsonify, render_template
-from flask_login import login_required, login_user, \
-    logout_user, current_user
-from config import Auth
-import json
-from app import oauth, login_manager, db
-
-
-google = oauth.remote_app(
-    'google',
-    consumer_key=Auth.CLIENT_ID,
-    consumer_secret=Auth.CLIENT_SECRET,
-    request_token_params={
-        'scope': 'https://www.googleapis.com/auth/userinfo.email'
-    },
-    base_url=Auth.BASE_URL,
-    request_token_url=None,
-    access_token_method='POST',
-    access_token_url=Auth.ACCESS_TOKEN_URL,
-    authorize_url=Auth.AUTHORIZE_URL,
-)
-
-login_routes = Blueprint('login', __name__)
-
-
-@login_routes.route('/')
-def index():
-    # if current_user.is_authenticated:
-    #     return jsonify(current_user.email)
-    return render_template('index.html')
-
-
-@login_routes.route('/login')
-def login():
-    return google.authorize(callback=url_for('login.authorized', _external=True))
-
-
-@login_routes.route('/logout')
-@login_required
-def logout():
-    logout_user()
-    session.pop('google_token', None)
-    return redirect(url_for('login.index'))
-
-
-@login_routes.route('/oauth2callback')
-@google.authorized_handler
-def authorized(resp):
-    if resp is None:
-        return 'Access denied: reason=%s error=%s' % (
-            request.args['error_reason'],
-            request.args['error_description']
-        )
-    session['google_token'] = (resp['access_token'], '')
-    me = google.get('userinfo')
-    user_data = me.data
-    print(user_data)
-    return redirect(url_for('login.index'))
-
-
-@google.tokengetter
-def get_google_oauth_token():
-    return session.get('google_token')
-
-@login_manager.user_loader
-def load_user(user_id):
-    return User.query.get(int(user_id))
\ No newline at end of file
diff --git a/views/youtube.py b/views/youtube.py
deleted file mode 100644
index fa1e6a3..0000000
--- a/views/youtube.py
+++ /dev/null
@@ -1,111 +0,0 @@
-# -*- coding: utf-8 -*-
-from flask import Blueprint, redirect, url_for, session, request, jsonify, render_template
-from flask_login import login_required, login_user, \
-    logout_user, current_user
-import os
-
-
-# This OAuth 2.0 access scope allows for full read/write access to the
-# authenticated user's account and requires requests to use an SSL connection.
-SCOPES = ['https://www.googleapis.com/auth/youtube.force-ssl']
-API_SERVICE_NAME = 'youtube'
-API_VERSION = 'v3'
-
-
-youtube_routes = Blueprint('youtube', __name__)
-
-@app.route('/home)
-def home():
-  return
-
-
-
-
-@app.route('/')
-def index():
-  if 'credentials' not in flask.session:
-    return flask.redirect('authorize')
-
-  # Load the credentials from the session.
-  credentials = google.oauth2.credentials.Credentials(
-      **flask.session['credentials'])
-
-  client = googleapiclient.discovery.build(
-      API_SERVICE_NAME, API_VERSION, credentials=credentials)
-  
-  return search_list_by_keyword(client,
-    part='snippet',
-    maxResults=25,
-    q='dogs',
-    type='')
-
-
-@app.route('/authorize')
-def authorize():
-  # Create a flow instance to manage the OAuth 2.0 Authorization Grant Flow
-  # steps.
-  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-      CLIENT_SECRETS_FILE, scopes=SCOPES)
-  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
-  authorization_url, state = flow.authorization_url(
-      # This parameter enables offline access which gives your application
-      # both an access and refresh token.
-      access_type='offline',
-      # This parameter enables incremental auth.
-      include_granted_scopes='true')
-
-  # Store the state in the session so that the callback can verify that
-  # the authorization server response.
-  flask.session['state'] = state
-
-  return flask.redirect(authorization_url)
-
-
-@app.route('/oauth2callback')
-def oauth2callback():
-  # Specify the state when creating the flow in the callback so that it can
-  # verify the authorization server response.
-  state = flask.session['state']
-  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-      CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)
-  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
-
-  # Use the authorization server's response to fetch the OAuth 2.0 tokens.
-  authorization_response = flask.request.url
-  flow.fetch_token(authorization_response=authorization_response)
-
-  # Store the credentials in the session.
-  # ACTION ITEM for developers:
-  #     Store user's access and refresh tokens in your data store if
-  #     incorporating this code into your real app.
-  credentials = flow.credentials
-  flask.session['credentials'] = {
-      'token': credentials.token,
-      'refresh_token': credentials.refresh_token,
-      'token_uri': credentials.token_uri,
-      'client_id': credentials.client_id,
-      'client_secret': credentials.client_secret,
-      'scopes': credentials.scopes
-  }
-
-  return flask.redirect(flask.url_for('index'))
-
-def channels_list_by_username(client, **kwargs):
-  response = client.channels().list(
-    **kwargs
-  ).execute()
-
-  return flask.jsonify(**response)
-
-def print_response(response):
-  print(response)
-
-def search_list_by_keyword(client, **kwargs):
-  # See full sample for function
-  print (flask.session['credentials']['client_id'])
-  response = client.search().list(
-    **kwargs
-  ).execute()
-  print ( response['items'])
-  return flask.jsonify(**response)
-
diff --git a/youtube.py b/youtube.py
deleted file mode 100644
index fa1e6a3..0000000
--- a/youtube.py
+++ /dev/null
@@ -1,111 +0,0 @@
-# -*- coding: utf-8 -*-
-from flask import Blueprint, redirect, url_for, session, request, jsonify, render_template
-from flask_login import login_required, login_user, \
-    logout_user, current_user
-import os
-
-
-# This OAuth 2.0 access scope allows for full read/write access to the
-# authenticated user's account and requires requests to use an SSL connection.
-SCOPES = ['https://www.googleapis.com/auth/youtube.force-ssl']
-API_SERVICE_NAME = 'youtube'
-API_VERSION = 'v3'
-
-
-youtube_routes = Blueprint('youtube', __name__)
-
-@app.route('/home)
-def home():
-  return
-
-
-
-
-@app.route('/')
-def index():
-  if 'credentials' not in flask.session:
-    return flask.redirect('authorize')
-
-  # Load the credentials from the session.
-  credentials = google.oauth2.credentials.Credentials(
-      **flask.session['credentials'])
-
-  client = googleapiclient.discovery.build(
-      API_SERVICE_NAME, API_VERSION, credentials=credentials)
-  
-  return search_list_by_keyword(client,
-    part='snippet',
-    maxResults=25,
-    q='dogs',
-    type='')
-
-
-@app.route('/authorize')
-def authorize():
-  # Create a flow instance to manage the OAuth 2.0 Authorization Grant Flow
-  # steps.
-  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-      CLIENT_SECRETS_FILE, scopes=SCOPES)
-  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
-  authorization_url, state = flow.authorization_url(
-      # This parameter enables offline access which gives your application
-      # both an access and refresh token.
-      access_type='offline',
-      # This parameter enables incremental auth.
-      include_granted_scopes='true')
-
-  # Store the state in the session so that the callback can verify that
-  # the authorization server response.
-  flask.session['state'] = state
-
-  return flask.redirect(authorization_url)
-
-
-@app.route('/oauth2callback')
-def oauth2callback():
-  # Specify the state when creating the flow in the callback so that it can
-  # verify the authorization server response.
-  state = flask.session['state']
-  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
-      CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)
-  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)
-
-  # Use the authorization server's response to fetch the OAuth 2.0 tokens.
-  authorization_response = flask.request.url
-  flow.fetch_token(authorization_response=authorization_response)
-
-  # Store the credentials in the session.
-  # ACTION ITEM for developers:
-  #     Store user's access and refresh tokens in your data store if
-  #     incorporating this code into your real app.
-  credentials = flow.credentials
-  flask.session['credentials'] = {
-      'token': credentials.token,
-      'refresh_token': credentials.refresh_token,
-      'token_uri': credentials.token_uri,
-      'client_id': credentials.client_id,
-      'client_secret': credentials.client_secret,
-      'scopes': credentials.scopes
-  }
-
-  return flask.redirect(flask.url_for('index'))
-
-def channels_list_by_username(client, **kwargs):
-  response = client.channels().list(
-    **kwargs
-  ).execute()
-
-  return flask.jsonify(**response)
-
-def print_response(response):
-  print(response)
-
-def search_list_by_keyword(client, **kwargs):
-  # See full sample for function
-  print (flask.session['credentials']['client_id'])
-  response = client.search().list(
-    **kwargs
-  ).execute()
-  print ( response['items'])
-  return flask.jsonify(**response)
-
